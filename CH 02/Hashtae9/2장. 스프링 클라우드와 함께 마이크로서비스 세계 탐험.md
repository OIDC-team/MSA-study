## 스프링 클라우드란?
> 오픈소스 회사의 제품을 전달 패턴으로 모아놓은 도구 집합
> 	VMWare, HashiCorp, 넷플릭스
+ 프로젝트 설정 및 구성 단순화 가능
	+ 배포에 필요한 모든 인프라스트럭처 구성에 대한 세부사항은 신경쓰지 않아도 됨
<br>
### <span style = "color:green">스프링 클라우드 컨피그</span>
> 애플리케이션 구성 데이터 관리
+ 애플리케이션 구성 데이터(특히, 환경별 구성 데이터)는 배포된 MSA에서 완전히 분리
+ 인스턴스가 많이 실행되어도 동일한 구성을 보장 가능
	+ 깃, 콘술, 넷플릭스 유레카
<br>
### <span style = "color:green">스프링 클라우드 서비스 디스커버리</span>
> 서비스를 소비하는 클라이언트에서 서버가 배포된 물리적 위치(IP 및 서버이름)을 추상화
+ 논리적 이름을 사용해 서버의 비즈니스 로직 호출 가능
+ 서비스 인스턴스가 시작되고 종료될 때 인스턴스 등록 및 등록 취소도 처리
	+ 콘술, 주키퍼, 유레카
<br>
### <span style = "color:green">스프링 클라우드 로드 밸런서와 Resilience4j</span>
> 마이크로서비스 클라이언트 회복성 패턴을 위해 사용
+ 마이크로 서비스 내부에서 Resilience4j와 스프링 클라우드 로드밸런서 활용
+ Resilience4j(라이브러리)
	+ 회로 차단기, 재시도, 벌크헤드
+ 스프링 클라우드 로드 밸런서 프로젝트
	+ 유레카 같은 서비스 디스커버리 에이전트와 통합하는 것을 단순화
	+ 서비스 소비자 호출에 대한 클라이언트 부하 분산 기능 제공
<br>
### <span style = "color:green">스프링 클라우드 API 게이트웨이</span>
> 마이크로서비스 애플리케이션을 위한 서비스라우팅 기능을 제공
+ 서비스 요청을 프록싱(proxying)하고 대상 서비스가 호출되기 전에 모든 호출이 '현관'을 통하도록 하는 게이트웨이
+ 서비스 호출의 집중화
	+ 보안인가, 인증, 콘텐츠 필터링과 라우팅 규칙 등 표준 서비스 정책을 시행할 수 있음
<br>
### <span style = "color:green">스프링 클라우드 스트림</span>
> 경량 메시지 처리 기능을 마이크로서비스에 쉽게 통합하는 기술
+ 애플리케이션에서 발생하는 비동기 이벤트를 사용하는 지능형 마이크로서비스를 구축가능
+ RabbitMQ와 카프카 같은 메시지 브로커와 마이크로서비스를 통합 가능
<br>
### <span style = "color:green">스프링 클라우드 슬루스</span>
> 고유한 추적 식별자를 애플리케이션에서 사용되는 http호출 및 메시지 채널(카프카, RabbitMQ)에 통합
+ 상관관계 ID or 트레이스 ID라고도 하는 추적번호를 사용하면 애플리케이션 내 여러 서비스를 통과하는 트랜잭션을 추적 가능
+ ELK 스택
	+ 로깅 집계 기술 도구
		+ Elasticsearch : 검색 및 분석 엔진
		+ Logstash : 데이터를 소비한 후 "stash"로 전송하기 위해 변환하는 서버 사이드 데이터 프로세싱 파이프라인
		+ Kibana : 사용자가 전체 스택의 데이터를 query하고 시각화할수 있는 클라이언트 UI
+ 집킨
	+ 스프링 클라우드 슬루스에서 생성한 데이터를 받아 단일 트랜잭션과 연결된 서비스 호출 흐름 시각화
<br>
### <span style = "color:green">스프링 클라우드 시큐리티</span>
> 서비스에 액세스 할 수 있는 사용자와 이 사용자가 서비스에서 수행할 수 있는 작업을 제어하는 인증 및 인가(권한 부여) 프레임워크
+ 토큰을 기반으로 소로 통신 가능
+ http 호출을 받는 각 서비스는 전달받은 토큰을 확인하여 사용자의 신원과 액세스 권한을 검증
+ JWT 지원
	+ OAuth2 토큰 생성 포맷을 표준화하고 생성된 토큰에 대한 서명을 정규화


<br>
---
## 클라우드 네이티브 마이크로 서비스 구축 방법
### 클라우드?
> 특정 자오가 아니라 가상의 인프라 스트럭처를 사용하여 로컬 머신과 사설 데이터 센터를 대체할 수 있는 기술 자원의 관리 시스템
<br>
#### 클라우드 레디(cloud-ready)
> 애플리케이션의 구성정보를 외부화하여 다양한 환경에 맞게 신속히 적용
> 애플리케이션은 빌드 중 소스코드를 변경하지 않고 여러 환경에서 실행되도록 함
<br>
#### 클라우드 네이티브(cloud-native)
> 기능을 컨테이너 같은 확장 가능한 마이크로서비스로 나눠 여러 서버에 실행
+ 이 후 서비스는 지속적 던달 워크플로가 지원되는 DevOps 프로세스를 이용하여 가상의 인프라스트럭처에서 관리
<br>
❗️클라우드 네이티브 4원칙
1. DevOps
	+ 개발자와 IT운영 간 커뮤니케이션과 협업, 통합에 중점을 둔 SW개발 방법론
	+ SW 전달 프로세스와 인프라스트럭처의 변경을 저렴한 비용으로 자동화
<br>
2. 마이크로서비스는 작고, 느슨하게 결합된 분산 서비스
	+ 대규모 애플리케이션을 좁게 정의된 책임을 가진 관리하기 쉬운 컴포넌트로 분해
	+ 대규모 코드베이스에서 발생하는 복잡성 해결 가능
<br>
3. 지속적 전달(continuous delivery)은 소프트웨어 개발 관행이다.
	+ 소프트웨어 전달 프로세스를 자동화하여 운영 환경에서 단기간 전달(배포) 가능
<br>
4. 컨테이너는 가상 머신(VM)이미지에 마이크로서비스를 배포하는 자연스러운 확장
	+ 클라우드에 도커 컨테이너를 활용해 배포
<br>
### 12 팩터

![](https://blog.kakaocdn.net/dn/dB9axI/btr0NH6eHv7/kBdxXOSKjBJYgBvxk8cz40/img.png)

https://www.linkedin.com/pulse/thetwelve-factor-app-methodology-ashish-kumar-singal/
<br>
**1. Codebase (코드베이스)**
+ 각 마이크로서비스는 버전 관리되는 git 혹은 svn과 같이 소스 제어 가능한 단일 코드베이스를 가짐 
+ 코드베이스는 여러 배포 환경(local, dev, test, staging, prod)을 포함할 수 있지만 다른 마이크로서비스와 공유되지 않는다는 것이 특징
	+ 만약 타 마이크로서비스와 공유가 될 경우 dependency가 생겨 제약 사항이 생길 수 있기 때문
<br>
**2. Dependencies (의존성)**
+ 애플리케이션이 Maven 혹은 Gradle과 같은 자바용 빌드 도구로 사용하면 항상 동일한 라이브러리 버전으로 마이크로서비스를 빌드
+ Maven의 경우 pom.xml 파일에 정의된 의존성을 읽어 로컬 Maven 저장소(.m2 repository)에서 검색하고 로컬에 없는 jar 파일일 경우 중앙 Maven 저장소(Central Maven Repository)에서 내려받고 추후 사용을 위해 로컬 저장소에 추가
<br>
**3. Config (구성 정보)**
+ 마이크로서비스에서 명심해야 할 부분은 절대로 소스 코드에 설정 정보를 추가하지 않는 것
+ 설정 정보의 경우 배포할 마이크로서비스와 완전히 분리해서 관리하는 것이 최선이며 Spring Cloud의 경우 Config Server를 별도로 배치한 뒤 config 정보가 바뀔 경우 별도 배포 없이 kafka 혹은 rabbitmq를 통해 bus refresh를 하여 Eureka 서버에 등록된 서버에 적용
	+ 만약 소스 코드에 설정 정보가 있을 경우 모든 마이크로서비스를 재배포해야 하기 때문에 비효율적
<br>
**4. Backing Services(백엔드 서비스)**
+ 마이크로서비스는 대개 다른 서버와 네트워크로 통신합니다.
	+ 이 경우 애플리케이션의 코드 변경 없이 로컬 및 써드 파티와 연결하는데 배포 구현체를 교체할 수 있어야 함
	+ 예를 들어 별도 코드 수정 없이 요구사항에 따라 파일을 NAS에 저장하다가 AWS S3에 저장할 수 있어야 함
<br>
**5. Build, Release, Run(빌드, 릴리즈, 실행)**
+ 애플리케이션 배포 단계 즉, 빌드, 릴리즈, 그리고 실행 단계는 철저히 분리되어야 함
+ 코드가 빌드되면 런타임 변경 사항은 빌드 프로세스를 거쳐 재배포되어야 하고 빌드된 서비스는 변경될 수 없어야 함
+ 각 단계를 분리하지 않을 경우 변경 사항을 추적하지 못하거나 별도 공수를 들여 코드를 수정해야 하는 일이 발생할 수 있음
	+ 예를 들어 prod 환경에 이미 배포된 서비스를 변경한다면, 이 변경 사항은 코드베이스에 저장되지 않아 서비스의 새 버전에 변경 사항이 누락되거나 새 버전에 변경 사항을 다시 복사해야 하는 사항이 발생할 수 있음
<br>
**6. Process(프로세스)**
+ 마이크로서비스는 항상 stateless 상태가 되어야 하며 요청받은 트랜잭션을 수행하는 데 필요한 정보만 포함
+ 마이크로서비스는 서비스 인스턴스 손실로 데이터가 손실될 것이라는 걱정 없이 언제든 중단 및 교체 가능해야 함
+ 상태를 저장해야 할 경우 Redis와 같은 메모리 케시나 백업 DB를 사용하여 수행
<br>
**7. Port Binding(포트 바인딩)**
+ 포트 바인딩은 애플리케이션이 특정 포트 번호를 사용하도록 지정하는 것
+ 포트는 IP 주소와 결합하여 네트워크 통신에서 사용되며 애플리케이션이 특정 포트 번호와 결합되어 실행될 때, 해당 포트를 통해 들어오는 모든 요청은 애플리케이션으로 전달
+ 특정 포트 번호를 사용함으로써, 애플리케이션은 네트워크에서 요청을 받고, 응답을 전송 

마이크로서비스 아키텍처에서 마이크로서비스는 서비스 실행 파일로 패키징 된 <span style = "color:blue">서비스용 런타임 엔진이 포함</span>되어 완전히 독립적입니다.
따라서, 별도의 웹서버나 애플리케이션 서버 없이 서비스를 실행할 수 있어야 하며 해당 서비스는 노출된 HTTP 포트를 사용하여 바로 액세스가 가능해야 합니다.
<br>
**8. Concurrency(동시성)**
+ 클라우드 네이티브 애플리케이션은 병렬 처리를 지원
+ 애플리케이션은 대개 동시에 처리해야 할 많은 요청이 있는데 이때 동시성을 지원하지 않으면, 애플리케이션은 하나의 요청을 처리할 때까지 다른 요청을 처리하지 못하고 기다려야 하는 문제가 발생
	+ 이는 애플리케이션의 처리 속도를 저하시키고, 사용자 경험을 저하시킬 수 있음  
	+ 따라서 12 Factor App에서는 애플리케이션이 병렬 처리를 지원하도록 설계해야 한다고 강조
+ 동시성 향상을 위해서는 수직 확장(scale up) 혹은 수평 확장(scale out)을 적용
	+ 수직 확장(scale up)은 인스턴스의 하드웨어를 spec up 시키는 것이며 주로 ram을 늘림(cpu도 늘림)
	+ 수평 확장(scale out)의 경우 애플리케이션의 인스턴스를 더 추가하는 것
<br>
12 팩터 앱에서는 확장이 필요할 경우 수직 확장 대신 더 많은 인스턴스를 띄워서 수평 확장하는 것을 추천합니다.
<br>
**9. Disposability(폐기 가능)**
<br>
+ Disposability란 애플리케이션이 즉시 시작되고 중지될 수 있는 능력을 가지고 있어야 한다는 것을 의미
+ 이를 통해 애플리케이션의 가용성을 높일 수 있으며, 장애 발생 시 복구 시간을 최소화
+ Disposability를 구현하기 위해서는 다음과 같은 요소를 고려해야 합니다.
	- **프로세스의 빠른 시작과 중지:** 애플리케이션이 시작되고 중지되는 데 걸리는 시간을 최소화해야 하며 이를 위해 프로세스의 초기화 과정을 간소화하고, 미리 초기화된 상태에서 시작
	- **상태 저장 및 복원:**가용성을 높이기 위해 애플리케이션이 중지되더라도 이전 상태를 저장하고 복원 
	- **무상태(Stateless) 설계:** 가용성을 높이기 위해 애플리케이션은 외부 상태에 의존하지 않고, 모든 상태 정보를 로컬 스토리지나 캐시 등에 저장
<br>
Disposability는 클라우드 네이티브 애플리케이션을 구현하는 데 매우 중요한 요소입니다.
클라우드 환경에서는 애플리케이션이 자주 시작되고 중지되기 때문에, Disposability를 고려하지 않으면 애플리케이션의 가용성이 저하될 수 있습니다.
<br>
**10. Dev/Prod Parity(개발 및 운영 환경 일치)**
+ 애플리케이션이 dev 환경, staging, prod 환경에서 최대한 일치해야 한다는 것을 의미
+ 이를 통해 애플리케이션의 배포 및 운영 과정에서 발생하는 문제를 최소화할 수 있음 
+ Dev/Prod Parity를 구현하기 위해서는 다음과 같은 요소를 고려
	-   **동일한 환경 설정:** 개발 환경과 운영 환경의 환경 설정이 가능한한 일치 
	-   **동일한 종속성 관리:** 개발 환경과 운영 환경에서 사용되는 종속성이 동일
	-   **동일한 배포 프로세스:** 개발 환경과 운영 환경에서의 배포 프로세스가 동일
<br>
**11. Logging(로깅)**
+ MSA 구조를 채택할 경우 서비스가 분산되어 있기 때문에 각각의 서비스에서 발생하는 로그도 분산
+ 따라서 각 마이크로서비스에서 출력된 로그는 수집되고 중앙 저장소에 기록하는 logstash나 fluentd와 같은 도구로 관리
	+ 여기서 중요한 점은 각각의 마이크로서비스는 이러한 내부 동작 메커니즘에 관여하지 않고 표준 출력으로 로그를 기록하는 것에만 집중한다는 것
<br>
**12. Admin Process(관리 프로세스)**
+ 애플리케이션 관리 작업을 위한 별도의 프로세스를 사용하는 것을 의미
+ 이러한 프로세스는 일반적으로 백그라운드로 실행되며, 애플리케이션의 데이터베이스나 캐시 등을 관리하는 데 사용
<br>
관리 프로세스는 다음과 같은 작업을 수행합니다.
-   **데이터베이스 마이그레이션:** 데이터베이스 스키마 변경 등과 같은 데이터베이스 관리 작업을 수행
-   **백업과 복원:** 데이터베이스나 파일 시스템 등을 백업하고, 복원하는 작업을 수행
-   **캐시 관리:** 캐시 메모리를 관리하고, 필요에 따라 초기화하는 작업을 수행
-   **세션 관리:** 세션 데이터를 관리하고, 만료된 세션을 삭제하는 작업을 수행
-   **로그 관리:** 애플리케이션 로그를 관리하고, 필요한 경우 압축하거나 삭제하는 작업을 수행
<br>
위와 같은 프로세스는 소스 코드 저장소에서 관리 및 유지되는 스크립트로 수행되어야 하며 스크립트가 실행되는 모든 환경에서 반복 가능하고 변경되지 않아야 하며 각 환경에 따라 개별 수정되지 않아야 합니다.