3 . 스프링 부트로 마이크로서비스 구축하기

아키텍트 

소프트웨어 개발자

데브옵스

3.1 마이크로서비스 아키텍처 설계

해결해야 할 문제의 작동모델을 제공

3.1.1 비즈니스 문제 분해

아키텍트는 비즈니스 문제를 각 활동 영역을 대표하는 덩어리로 분해하고 비즈니스 영역의 특정 부분과 연관된 비즈니스 규칙과 데이터 로직을 안에 은닉한다.

비즈니스 영역을 분해

비즈니스 문제를 기술하는 데 사용된 명사에 주목하라

동사에 주목하라

데이터 응집성을 찾아라 연관성 높은 데이터를 찾아야함


3.1.2 서비스 세분화 확정

주요 기능 부분을 서로 독립적으로 빌드하고 배포할 수 있는 완전한 자립형 유닛을 추출

유닛은 디비를 공유하거나 개별적으로 가질 수 있음

데이터 모델에서 서비스를 추출하는 것은 코드를 개별 프로젝트로 다시 패키징 하는 것 이상이 필요

이 추출 작업은 서비스가 액세스 하는 실제 데이터 베이스 테이블을 파악하고 특정 문제 영역의 테이블에만 액세스를 허용하는 것도 포함



마이크로 서비스는 광범위하게 시작하고 더 작은 서비스로 리팩터링 하는 것이 좋다.

서비스 간 교류하는 방식에 중점을 둔다.

문제 도메인에 이해가 깊어지면서 서비스 책임도 계속 변한다.



나쁜 마이크로서비스 징후

책임이 너무 많은 서비스,

다수 테이블에 걸쳐 데이터를 관리하는 서비스, 

테스트가 너무 많은 서비스

작은 서비스는?

문제 도메인의 한 부분에 속한 마이크로서비스가 토끼처럼 번식한다.

마이크로서비스가 지나치게 상호 의존적이다.

마이크로서비스가 단순한 crud 서비스 집합이 된다.


3.1.3 서비스 인터페이스 설계

상호통신방식의 정의

rest철학을 수용하라

uri를 사용하여 의도를 전달하라

요청과 응답에 json을 사용하라

http 상태 코드로 결과를 전달하라


3.2 마이크로서비스를 사용하지 말아야 할 때

3.2.1 분산 시스템 구축의 복잡성

분산되고 세분화 되어 모놀리식 애플리케이션에서 없던 복잡성이 발생한다.

높은 운영 성숙도 필요

=> 자동화와 운영 작업에 기꺼이 투자해야함


3.2.2 서버 또는 컨테이너 스프롤

배포 모델은 컨테이너당 하나의 마이크로서비스 인스턴스를 배포하는 것


3.2.3 애플리케이션 타입

재사용성을 추구하며 고도의 회복성과 확장성이 필요한 대규모 애플리케이션을 구축하는 데 매우 유용


3.2.4 데이터 트랜잭션과 일관성

데이터 사용 패턴 -> 여러 데이터 소스에 걸쳐 복잡한 데이터를 집계하고 변환


3.3 개발자 이야기 : 스프링 부트와 자바

라이선싱 서비스 엔드포인트를 노출하도록 엔드포인트 매핑용 스프링 부트 컨트롤러 클래스 구현

타 언어 메세지를 적용할 수 있는 국제화 구현

사용자가 서버와 상호 작용할 수 있도록 충분한 정보를 제공하는 스프링 HATEOAS 구현


3.3.1 마이크로서비스의 출입구 만들기: 스프링 부트 컨트롤러

서비스의 엔드포인트를 노출하고 유입되는 http 요청 데이터를 요청을 처리할 자바 메소드를 매핑한다.

post get put delete 매핑되는 네개의 http 엔드포인트를 노출한다.


모든 서비스의 엔드포인트를 최상위 엔드포인트인

@RequestMapping(value=”v1/organiztion/{organizationId}/license) 시작


@RestController json xml 데이터 직렬화


3.2.2 라인선싱 서비스에 국제화 추가하기

애플리케이션을 다른 언어에 적응할 수 있도록 하는 필수요구사항


1.기본 로케일 설정
2.메시지가 발견되지 않아도 에러를 던지지 않고 대신 메시지 코드를 반환
3.언어 프로퍼티 파일의 기본 이름을 설정한다

메세지 구성->properties

1.메서드 매개변수로 로케일을 전달 받는다
2.특정 메시지를 조회하기 위해 전달된 로케일로 설정
3.특정 메시지를 조회하기 위해 null 로케일을 전달한ㄷ.

요청 헤더 값을 메서드 매개변수에 매핑하는 사용
@RequsetHaeder

요청 헤더인 Aceept-language에서 로케일을 가져온다

3.3.3 관련 링크를 표시하는 스프링 HATEOAS 구현 ---?...

해당 리소스와 관련된 링크를 표시하는 원칙을 준수하는 API 생성





3.4 데브옵스 이야기
마이크로서비스는 일체형
마이크로서비스는 구성가능
마이크로서비스 인스턴스는 클라리언트에 투명해야
마이크로서비스는 자기 상태를 전달

운영수명주기
서비스 조립: 동일한 서비스 코드와 런타임이 정확히 동일한 방식으로 배포-> 반복성, 일관성->패키징
서비스 부트스트래핑: 마이크로서비스를 사람의 개입없이 모든 환경에서 빠르게 시작, 런타임 코드에서 애플리케이션 코드와 환경별 구성 코드를 분리하는 방법
서비스 등록 및 디스커버리: 새 마이크로서비스 인스턴스가 배포될 떄 애플리케이션 클라이언트가 새 서비스 인스턴스를 발견할 수 있는 방법
서비스 모니터링: 높은 가용성이 요구, 한 서비스에 여러 인스턴스를 실행하는 것이 일반적, 장애가 발생한 서비스 인스턴스를 우회해서 라우팅하고 종료

3.4.1 서비스 조립

애플리케이션의 환경 변화에 대응하여 마이크로서비스의 많은 인스턴스를 신속히 배포
->정리된 모든 의존성을 포함한 단일 산출물로 패키징되고 설치 될 수 있어야함
마이크로서비스를 호스팅하는 런타임 엔진(HTTP 서버나 애플리케이션 컨테이너)도 이들 의존성에 포함
<img width="627" alt="image" src="https://github.com/OIDC-team/MSA-study/assets/96863137/2022160b-3bdb-486b-97e9-2887d65bda30">

 스프링 부트 예제에서 메이븐과 스프링 부트는 내장형 톰캣 엔진을 포함하여 JAR 실행 파일을 빌드 ->다음 명령줄 예에서 라이선싱 서비스를 JAR 실행 파일로 빌드하고 JAR를 실행한다.

많은 조직에서 애플리케이션 서버의 구성 정보를 소스 제어 저장소에서 관리하지 않고 사용자 인터페이스나 자체 관리 스크립트로 관리 X ->애플리케이션 서버 환경에서 구성 불일치(configuration drift)가 너무 쉽게 발생하여 표면적으로 무작위 장애

3.4.2 서비스 부트스트래핑: 마이크로서비스의 구성 관리
단계인 서비스 부트스트래핑(service bootstrapping)은 마이크로서비스가 처음 시작하고 애플리케이션 구성 정보를 로드할 때 일어남

<img width="501" alt="image" src="https://github.com/OIDC-team/MSA-study/assets/96863137/4f6b2cab-6007-4626-920b-ee0a3ce7188f">

마이크로서비스는 대개 동일한 종류의 구성을 요구, 차이점은 클라우드에서 실행되는 마이크로서비스 애플리케이션에는 수백 또는 수천 개의 마이크로서비스가 실행될 수 있다는 것이다.

클라우드의 마이크로서비스 상황에서는 다음 몇 가지 고유한 난제

• 구성 데이터는 구조가 단순한 편이라서 보통 자주 읽고(read) 간혹 쓴다(write). 관계형 데이터베이스는 단순한 키-값 조합보다 훨씬 더 복잡한 데이터 모델을 관리하는 용도로 설계되었기 때문
• 데이터는 정기적으로 액세스되지만 드물게 변경되므로 데이터의 읽기 지연 시간은 낮아야 함
• 데이터 저장소는 고가용성을 유지하고 데이터를 읽는 서비스에 가까워야 한다. 구성 데이터 저장소는 애플리케이션의 단일 장애 지점이기 때문에 완전히 다운되면 X

3.4.3 서비스 등록과 디스커버리: 클라이언트가 마이크로서비스와 통신하는 방법




















+ spring cloud

<img width="818" alt="image" src="https://github.com/OIDC-team/MSA-study/assets/96863137/3fc8474c-20ee-425c-ac66-516b8713e681">



