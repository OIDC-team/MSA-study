## <span style = "color : green">마이크로 서비스 아키텍처로 진화</span>

### N-계층 아키텍처
> UI, 서비스, 데이터, 테스팅 등 고유의 책임과 기능이 있는 여러 계층으로 나뉨

**장점**
+ 관심사가 잘 분리되어 있어서 UI, 데이터, 비즈니스 로직 같은 영역을 따로 고려 가능
+ 팀이  N-계층 애플리케이션의 여러 컴포넌트에서 독립적으로 작업하기 쉬움

**단점**
+ 변경을 적용하려면 전체 애플리케이션을 중지하고 재시작
+ 메시지가 상하 전체 계층에 통행하기에 비효율적
+ 리팩터링이 어려움

### 모놀리식 아키텍처
> 배포 가능한 하나의 산출물로 생성
+ UI,비즈니스 로직,데이터베이스 엑세스 로직 모두 하나의 어플리케이션으로 합쳐져 패키징되고 서버에 배포.
<img width="705" alt="스크린샷 2023-04-16 오후 10 39 02" src="https://user-images.githubusercontent.com/101400894/232315256-62a801af-8a30-4135-b292-bd107c1bcae7.png">
**장점**
+ 구축 및 배포가 쉬움
+ 사용사례가 잘 정의되어 있고 변경 가능성이 낮다면 best

**문제점**
-   문제가 생길때마다 **어플리케이션 전체를 다시 빌드하고 테스트 및 배포**
-   애플리케이션 내부에서 사용되는 모든 데이터 소스의 접근 정보가 전체 어플리케이션에 노출

### 마이크로서비스
> 애플리케이션 기능을 분해하고 분리하여 완전히 상호 독립적으로 실행
<img width="704" alt="스크린샷 2023-04-16 오후 10 45 36" src="https://user-images.githubusercontent.com/101400894/232315572-02679fe4-a054-4755-bfb9-7ec648faca96.png">

**장점**
+ 작고 느슨하게 결합된 분산 서비스이기에 대규모 애플리케이션을 책임이 명확하고 관리하기 쉬운 구성요소로 분해 가능
	+ 애플리케이션의 기능은 완전히 상호독립적이어야 함.(명확하고 대등한 책임 경계가 있는 작은 컴포넌트로 분해)
	+ 각 영역은 독립적으로 배포
	+ 서비스 소지자와 공급자 간 데이터 교환은 HTTP와 JSON같은 경량의 통신 프로토콜 사용

#### 모놀리식 vs 마이크로서비스
<img width="715" alt="스크린샷 2023-04-16 오후 10 50 51" src="https://user-images.githubusercontent.com/101400894/232315831-b3e8ddbf-bdbd-4b54-a63c-e1a9dc91081a.png">
### why MSA?
1. 복잡성 증가
	+ 더 이상 사내 데이터만을 이용한 서비스 제공이 아닌 외부 인터넷 서비스 제공자에 있는 다양한 서비스와 데이터 통신 필요
2. 고객은 더 빠른 전달을 원함
	+ 빠른 기능 향상을 원함(서비스 배포의 주기가 빨라지길 원함)
3. 안정적인 성능과 확장성을 요구
	+ 더 이상 내수시장이 아닌 글로벌 고객 진출까지 고려하였을 때 트랜잭션 양이 얼마나 될지 모름
	+ 트랜잭션 양에 따라 서버를 신속하고 매끄럽게 확장하고 축소
4. 어플리케이션을 언제든 사용하길 기대
	+ 경쟁사와 한 클릭 차이 정도로 경쟁하기에 애플리케이션은 회복성이 높아야 함
		+ 한가지 기능의 문제가 전체의 문제로 확대되지 않아야 함


#### 해결법?
> 애플리케이션을 더 작은 서비스로 <span style = "color:red">분리</span>하고 단일 모놀리식 산출물에서 서비스 산출물을 추출
+ 유연성 : 분리된 서비스는 새로운 기능을 신속하게 제공하도록 구성, 재배치 가능
+ 회복성 : 고장이 어플리케이션 일부분에 국한되어 애플리케이션 전체 장애로 확대되기 전에 억제
+ 확장성 : 분리된 서비스는 여러 서버에 쉽게 수평 분산이 가능하기에 확장에 용이

❗️**small, simple, decoupled(분리된) 서비스 = 확장성, 회복성, 유연성있는 애플리케이션**





## <span style = "color : green">스프링 마이크로서비스</span>
### 스프링의 특징
+  DI(의존성 주입) : 의존성 주입 프레임워크를 사용하여 객체 관계를 외부화
	+ 각 클래스들끼리의 의존성을 프레임워크가 관리함으로써 클래스들은 **느슨한 결합**의 형태로 (SRP)단일책임원칙
+ 내장형 웹 서버
	+ Tomcat(기본), Jetty, Undertow...
	+ 사용된 웹 서버는 배포 가능한  JAR 일부로 포함

#### 스프링 부트에 마이크로서비스가 제공하는 이점
+ 스프링 데이터, 스프링 시큐리티, 스프링 클라우드 같은 스프링 생태계와 통합 용이
+ 개발 시간 단축, 효율성과 생산성 향상
+ 웹 애플리케이션 실행을 위한 내장형 HTTP 서버 제공
+ 스프링 프로젝트는 이미 클래스의 역할 분리, 컴퍼넌트의 분리로 경량성을 인정받고 있지만, 하나의 War,Jar에서 모든일이 일어나고 있기에 이를 더 분리하고 유연성과 확장성을 폭팔시키기 위해 마이크로서비스는 필수





## <span style = "color : green">책 전반적으로 다룰 서비스와 기술</span>
<img width="723" alt="스크린샷 2023-04-16 오후 11 13 30" src="https://user-images.githubusercontent.com/101400894/232318899-cd0b0038-58c2-4d05-9333-20b1ba7e6756.png">

## <span style = "color : green"> 클라우드 컴퓨팅</span>
> 인터넷을 통해 컴퓨팅과 가상화된 IT 서비스(DB, 네트워킹, SW, 서버, 분석 등)을 제공

### 클라우드 컴퓨팅 모델별 차이(XaaS)
<img width="720" alt="스크린샷 2023-04-16 오후 11 32 16" src="https://user-images.githubusercontent.com/101400894/232320096-603a6b22-57c7-42f8-b3e7-197bcf5f4e5f.png">
+ IaaS: 서버, 스토리지, 네트워크 같은 컴퓨팅 자원에 접근할 수 있는 인프라 스트럭처 제공
	+ 개발자가 서비스가 배포되는 가상머신을 관리
	+ AWS(EC2), Kubernetes, Azure Virtual Machine

+ CaaS: 컨테이너 기반 가상화의 한 형태
	+ 도커처럼 경량의 이식성 높은 가상 컨테이너 내 마이크로서비스를 클라우드 공급자 환경에 배포
	+ GKE, ECS

+ Paas: 사용자가 애플리케이션의 개발, 실행, 유지 관리에 집중할 수 있는 플랫폼과 환경 제공
	+ 사용자가 물리 인프라스트럭처에 투자할 필요가 없음
	+ 도구 관리에 신경x
	+ Google App Engine, Cloud Foundry, 헤로쿠, AWS Elastic Beanstalk

+ FaaS: 서버리스 아키텍쳐
	+ 서버리스 : 공급 업체가 필요한 모든 서버를 제공하는 클라우드 환경에서 기능의 실행 방법을 의미
	+ AWS(Lambda), Cloud Function, Azure Function

+ SaaS: 특정 애플리케이션을 배포하거나 유지 관리할 필요 없이 사용
	+ 웹 브라우저를 통해 대부분 통신
	+ Salesforce 및 SAP, Google Business


### 마이크로 서비스의 서비스 배포의 형태
1. 물리 서버
2. 가상 머신 이미지 : VM을 활용
3. 가상 컨테이너 : 도커 컨테이너를 통한 클라우드 배포(다수의 인스턴스를 IaaS에 배포)

❗️클라우드 기반의 마이크로 서비스 = **탄력성**
+ 몇 분안에 컨테이너를 가동, 요구량 감소에 따른 컨테이너 축소
	+ 확장성을 얻을 수 있음

#### CaaS 기반 클라우드 배포
> 도커 컨테이너 활용한 배포
+ 간소화된 인프라 스트럭처 관리 : 간단한 api호출로도 새로운 서비스를 시작하고 중지 가능
+ 대규모 수평 확장성 : 빠르고 간결하게 하나 이상의 인스턴스 시작 가능
+ 지리적 분산을 이용한 높은 중복성 : 공급자의 여러 데이터 센터를 활용

## <span style = "color : green"> 마이크로 서비스 주의점</span>
**Check-List**
1. 적정 규모 : 서비스가 한 가지 책임 영역에 집중되도록 하려면 어떻게 해야하는가?
2. 위치 투명성 : 서비스 클라이언트에 영향을 주지 않고 서비스 인스턴스를 추가하고 삭제하려면 물리적 위치를 어떻게 해야하는가?
3. 회복성 : 서비스에 문제가 있을 때 서비스 클라이언트가 실패하려면 어떻게 해야하는가?
4. 반복성 : 새로운 서비스가 시작할 때마다 항상 기존과 동일한 코드와 구성을 갖게 하려면 어떻게 하는가?
5. 확장성 : 서비스 간 종속성을 최소화 하면서 애플리케이션을 신속히 확장하려면 어떻게 해야하는가?

### 적정 규모
+ 마이크로 서비스가 너무 많은 책임을 지지 않도록 적절한 크기 유지

### 위치 투명성
+ 서비스 호출에 대한 물리적 상세 정보를 관리하는 방법
+ 마이크로서비스 애플리케이션에서 다수의 서비스 인스턴스가 빠르게 시작되고 종료될 수 있음

### 회복성
+ 실패한 서비스를 우회하고 "빠른 실패" 방식을 적용하여 소비자와 애플리케이션의 전반적인 무결성 보호

### 반복성
+ 서비스의 모든 새 인스턴스가 시작할 때 운영 환경의 다른 서비스와 동일한 구성과 코드베이스를 보장하는 방법

### 확장성
+ 서비스 간 직접적인 종속관계를 최소화 하고 마이크로서비스를 적절히 확장할 수 있도록 통신방식 구축


## <span style = "color : green"> 핵심 마이크로서비스 개발 패턴</span>
<img width="666" alt="스크린샷 2023-04-20 오후 8 35 08" src="https://user-images.githubusercontent.com/101400894/233354279-2a1db47e-45a5-42fb-a938-5d48a6175ad8.png">
### 서비스 세분성
+ 비즈니스 도메인을 마이크로서비스로 분해하여 각 서비스가 적정 수준의 책임을 갖도록 하는 방법

### 통신 프로토콜
+ 동기 프로토콜 - 바이너리 프로토콜(xml, json)을 사용하는 HTTP 기반 REST가 가장 일반적인 통신
+ 비동기 프로토콜 - RabbitMQ, 아파치 카프카, 아마존 SQS를 활용한 1대1, 1대多 통신을 하는 AMQP

### 인터페이스 설계
+ 인터페이스 설계 방법
+ 서비스 구조화 방법

### 서비스 구성관리
+ 클라우드에 있는 서로 다른 환경 간 마이크로 서비스의 구성을 호환하려면 어떻게 구성을 관리하는가?

### 서비스 간 이벤트 처리
+ 서비스 간 하드코딩된 의존성을 최소화하고 애플리케이션의 탄력성을 높이고자 이벤트를 사용하여 서비스를 분리하는 방법(스프링 클라우드 스트림으로 이벤트 기반 아키텍처)


## <span style = "color : green"> 마이크로서비스 라우팅 패턴</span>
> 마이크로서비스를 사용하려는 클라이언트 애플리케이션이 서비스 위치를 발견하고 서비스로 라우팅하는 방법

+ 보안과 콘텐츠 정책을 시행하려면 서비스의 물리적 IP를 추상화하고 서비스를 호출하는 단일 진입점이 필요
	+ 서비스 디스커버리
		+ 마이크로서비스를 탐색 가능하여 클라이언트 애플리케이션은 서비스 위치를 하드코딩하지 않아도 서비스를 찾을 수 있음
		+ 넷플릭스 유레카 서비스 디스커버리, etcd, 콘술, 아파치 주키퍼...
		+ 서비스 메시로 알려진 서비스 간 통신 인프라스트럭처(서비스 디스커버리대신 사용)
	+ 서비스 라우팅
		+ API게이트웨이를 사용하면 모든 서비스에 대한 단일 진입점을 제공하여 마이크로서비스 애플리케이션의 여러 서비스와 서비스 인스턴스에 대해 일관된 보안정책과 라우팅 규칙 적용 가능
		+ 스프링 클라우드 API 게이트웨이

<img width="602" alt="스크린샷 2023-04-20 오후 8 58 27" src="https://user-images.githubusercontent.com/101400894/233359274-6c790ad3-8681-4c41-8a48-0f002b75e96e.png">

## <span style = "color : green">마이크로서비스 클라이언트의 회복성</span>
> 하나의 서비스의 문제가 연쇄적으로 서비스 소비자까지 전파되는 것을 막는데 신중
+ 클라이언트 부하 분산
	+ 마이크로서비스의 여러 인스턴스에 대한 호출이 정상 인스턴스에 분산되도록 서비스 인스턴스 위치를 캐싱
+ 회로 차단기 패턴
	+ 실패중이거나 성능문제를 겪고 있는 서비스를 계속 호출하지 않도록 하는 방법
+ 폴백 패턴
	+ 호출 실패시 호출되는 마이크로서비스가 아닌 다른 수단으로 서비스 클라이언트가 작업을 수행할 수 있도록 '플러그인' 메커니즘 제공
+ 벌크헤드(격벽) 패턴
	+ 한 서비스의 오작동 호출이 애플리케이션의 다른곳에 나쁜 영향을 미치지 않도록 호출을 격리하는 방법

<img width="646" alt="스크린샷 2023-04-20 오후 9 11 09" src="https://user-images.githubusercontent.com/101400894/233362028-128e69b8-7d83-45d7-ab63-b63b7fe3ea64.png">

## <span style = "color : green"> 마이크로서비스 보안 패턴</span>
> 적절한 자격증명을 가진 승인된 요청만 서비스를 호출할 수 있도록 다음 보안 패턴을 아키텍처에 적용하는 것이 중요
+ 인증(Authentication)
	+ 서비스를 호출하는 서비스 클라이언트가 누구인지 확인
+ 인가(Authorization)
	+ 마이크로서비스를 호출하는 서비스 클라이언트가 수행하려는 행동에 대한 수행 자격 여부를 확인
+ 자격 증명 관리와 전파
	+ 서비스 클라이언트가 한 트랜잭션에서 여러 서비스를 호출할 때 계속해서 자격 증명을 제시하지 않는 방법
	+ OAuth2(사용자가 제삼자의 인증 서비스로 자신을 인증하는 프레임워크), JWT

<img width="629" alt="스크린샷 2023-04-20 오후 9 17 24" src="https://user-images.githubusercontent.com/101400894/233363386-c06bc1ac-de2e-4948-a6ef-14ee3ad4f3c7.png">


## <span style = "color : green"> 마이크로서비스 로깅과 추적 패턴</span>
> 마이크로서비스 -> 간단한 동작 하나에 수많은 마이크로서비스 호출이 발생할 수 있음.
> 	문제를 디버깅하고 추적, 모니터링이 어려움
+ 스프링 클라우드 슬루스, 집킨, ELK 스택을 활용한 분산 추적 구현 방법을 다룸
+ 로그 상관관계
	+ 사용자의 한 트랜잭션에 대해 여러 서비스에서 생성된 모든 로그를 함께 연결(상관관계 ID 구현)
+ 로그 수집
	+ 모든 로그를 질의(query)가능한 단일 DB에 수집, 트랜잭션 내 서비스 성능 특성 이해
+ 마이크로서비스 추적
	+ 트랜잭션과 관련된 모든 서비스 간 클라이언트 트랜잭션 흐름을 시각화 & 성능 특성 파악

<img width="649" alt="스크린샷 2023-04-21 오전 12 26 30" src="https://user-images.githubusercontent.com/101400894/233413863-ecedc6c7-2936-404c-8c3b-eb02f3a9a522.png">


## <span style = "color : green"> 애플리케이션 지표 패턴</span>
>  애플리케이션이 지표를 모니터링하는 방법과 애플리케이션의 가능한 실패원인을 경고하는 방법
+ 지표 : 애플리케이션 상태에 대해 중요한 정보 생성 및 지표 노출
+ 지표 서비스 : 애플리케이션 지표를 저장하고 질의하는 곳(pull, push방식으로 지표 가져옴)
+ 지표 시각화 제품군 : 애플리케이션과 인프라스트럭처에 대해 비즈니스와 연관된 시계열 데이터 시각화

❓push방식과 pull방식
+ push : 애플리케이션 데이터를 전송하려고 서비스 인스턴스 지표가 지표 서비스가 제공한 서비스 API 호출
+ pull : 지표서비스가 애플리케이션 데이터를 가져오는 함수에 요천하거나 질의하는것

<img width="652" alt="스크린샷 2023-04-21 오전 12 31 15" src="https://user-images.githubusercontent.com/101400894/233415143-73893c6b-8e8d-42e7-9bdb-167e38d5a85b.png">



## <span style = "color : green"> 마이크로서비스 빌드/배포 패턴</span>
> 각 인스턴스가 모두 동일해야함
> 서버가 배포된 후 서버의 변경사항으로 발생되는 구성 불일치는 안정성을 해침
+ 인프라 스트럭처 구성을 빌드/배포 프로세서에 통합해서 WAR, EAR파일 등 소프트웨어 산출물을 이미 실행중인 인프라스트럭처에 더 이상 배포하지 않는 것
+ 대신 빌드 프로세스 일부로 수행중인 마이크로서비스와 가상 서버 이미지를 빌드하고 컴파일

+ 빌드 및 배포 파이프라인 : 조직의 모든 환경에서 원 버튼 클릭 빌드와 배포를 중시하는 반복적인 빌드 및 배포 프로세스 구축
+ 코드형 인프라 스트럭처 : 소스 제어로 실행되고 관리되는 서비스 프로비저닝 처리방법
+ 불변 서버 : 마이크로 서비스 이미지가 생성되고 배포된 후 절대 변경되지 않도록 하는 방법
+ 피닉스 서버 : 개별 컨테이너를 실행하는 서버가 정기적으로 분해되어 불변 이미지로 재성성되도록 하는법

<img width="560" alt="스크린샷 2023-04-21 오전 12 35 48" src="https://user-images.githubusercontent.com/101400894/233416396-65d9489b-400d-48e9-ae53-6da2bcb9ac78.png">

---
출처
1. 존 카넬, 일러리 후알리루포 산체스, "스프링 마이크로서비스 코딩공작소 개정 2판", 정성권 옮김, 길벗(2022), p34-68.
2. https://velog.io/@geunwoobaek/스프링-마이크로서비스-1스프링-마이크로서비스-코딩-공작소-리뷰